(function(){

$(document).foundation();

var currentId;
var bubbles       = {};
var bubblesLocal  = {};

// connect to the server
var socket = io.connect();

// create a map of our space
var map = L.map('map', {
    center: [0, 0],
    zoom: 20,
    zoomControl: false,
    attributionControl: false
});

// create the sounds array/slots
var sounds = [];

for (var i = 0; i < 12; i++) {
    sounds.push(new buzz.sound( "/sounds/"+ (450 + (50 * i)) +".mp3", {
        volume      : 100,
        webAudioApi : true
    }));
};

// listen for event "identity" which returns our player ID (generated by the server)
socket.on('identity', function (data) {
    // store it
    currentId = data;

    // show the form
    $('#js-player-edit').foundation('reveal', 'open');
});

socket.on('update', function (data) {
    //console.log("update");
    bubbles = data;
    processBubbles();
});

// process the updates that the server is sending
var processBubbles = function() {
    // only handle bubbles that are ready to play
    _.each( bubbles, function(bubble,bubbleId) {
        if ( !bubble.ready ) {
            delete bubbles[bubbleId];
        }
    });

    // find and distinguish our own bubble
    var ownBubble = _.find( bubbles, function(bubble, bubbleId) {
        return bubbleId === currentId;
    });

    // store our position
    var ownBubblePosition;

    if ( ownBubble ) {
        ownBubblePosition = L.latLng( [ ownBubble.position.coords.latitude, ownBubble.position.coords.longitude ] );
    }

    // loop each bubble
    _.each( bubbles, function( bubble, bubbleId ) {
        var position = L.latLng( [ bubble.position.coords.latitude, bubble.position.coords.longitude ] );
        var size     = bubble.options.size;
        var slot     = bubble.slot;
        var color    = bubble.color;
        var name     = bubble.options.name;

        bubblesLocal[bubbleId] = bubblesLocal[bubbleId] || {};
        bubblesLocal[bubbleId].slot = slot;
        bubblesLocal[bubbleId].overlap = false;

        // map circle
        // if we don't have a circle, then it's a new player and we need to create one
        if ( !bubblesLocal[bubbleId].circle  ) {
            bubblesLocal[bubbleId].circle = L.circle(
                position,
                size,
                {
                    stroke: true,
                    color: color,
                    fillColor: color,
                    fillOpacity: 0.5
                }
            )
            .bindLabel( name, {
                noHide: true,
                direction: 'auto'
            })
            .addTo(map);
        }
        // otherwise, if it's a current player already with a circle, update the position, size and name
        else {
            bubblesLocal[bubbleId].circle.setLatLng( position );
            bubblesLocal[bubbleId].circle.setRadius( size );
            bubblesLocal[bubbleId].circle.updateLabelContent( name );
        }

        // if own bubble is ready to play... we can work out distance from other circles and how to play the sounds
        if ( ownBubble ) {
            // calculate distance from our own bubble
            bubblesLocal[bubbleId].distance = ownBubblePosition.distanceTo(position) - size - ownBubble.options.size;
            //console.log(name +" is "+ bubblesLocal[bubbleId].distance +"m away");

            // calculate frequency of the beeps
            bubblesLocal[bubbleId].soundGap = bubblesLocal[bubbleId].distance * 50; // this is just a multiplier to avoid too frequent beeps
            // maximum interval between beeps is 3 seconds
            if (bubblesLocal[bubbleId].soundGap > 3000) {
                bubblesLocal[bubbleId].soundGap = 3000;
            }

            // if it's not own bubble...
            if ( bubbleId !== currentId ) {

                // is this bubble overlapping? if yes then play in loop!
                if ( bubblesLocal[bubbleId].distance <= 0 ) {
                    clearTimeout( bubblesLocal[bubbleId].soundStop );
                    clearTimeout( bubblesLocal[bubbleId].soundStart );
                    clearTimeout( bubblesLocal[bubbleId].soundTimeout );
                    bubblesLocal[bubbleId].soundStart = false;
                    // play the sound in loop
                    sounds[ bubblesLocal[bubbleId].slot ].play().loop();
                    bubblesLocal[bubbleId].overlap  = true;
                }
                // if not overlapping... then beep!
                else {
                    // check if it was overlapping previously
                    if ( bubblesLocal[bubbleId].overlap ) {
                        // stop the looping sound
                        sounds[ bubblesLocal[bubbleId].slot ].unloop().stop();
                    }
                    // remember that it's not overlapping anymore
                    bubblesLocal[bubbleId].overlap = false;

                    // define the recurrent beep timeouts
                    bubblesLocal[bubbleId].soundFunction = function() {
                        // cancel any scheduled stop
                        clearTimeout( bubblesLocal[bubbleId].soundStop );

                        // remember that we are now in a recurring beep
                        bubblesLocal[bubbleId].soundStart = true;

                        // play the sound
                        sounds[bubblesLocal[bubbleId].slot].play();

                        // schedule stopping the sound, this defines how long the "beep" plays
                        bubblesLocal[bubbleId].soundStop = setTimeout( function() {
                            // ok, now we stop the "beep"
                            sounds[bubblesLocal[bubbleId].slot].stop();

                            bubblesLocal[bubbleId].soundTimeout = setTimeout( bubblesLocal[bubbleId].soundFunction, bubblesLocal[bubbleId].soundGap );
                        }, 100);
                    };

                    // if beep is not already playing from previously, then start it...
                    if ( !bubblesLocal[bubbleId].soundStart ) {
                        clearTimeout( bubblesLocal[bubbleId].soundStop );
                        clearTimeout( bubblesLocal[bubbleId].soundTimeout );
                        // fire it up, and make sure it's not at the same time as all other bubbles
                        bubblesLocal[bubbleId].soundStart = setTimeout( bubblesLocal[bubbleId].soundFunction, _.random(0,2000) );
                    }
                }
            }
        }

        // if it's our bubble, update all information around the user interface
        if ( bubbleId === currentId ) {
            $(".js-name").html(name);
            $(".js-size").html(size +"m bubble");
            $(".js-name").css("color",color);
            $(".js-count").html(_.size( _.filter(bubbles, function(bubble){ return bubble.ready; }) ) +" players");

            // keep map centered where our bubble is
            map.panTo( position );

            // make sure the loading thing is faded out
            $(".app-loading").velocity("fadeOut", { duration: 300 });
        }
    });

    // play our own looping sound
    if ( ownBubble ) {
        sounds[bubblesLocal[currentId].slot].play().loop();
    }

    // clear up bubbles/players that left
    var bubbleIds = _.keys( bubbles );

    _.each( bubblesLocal, function( bubble, bubbleId ) {
        if ( !_.contains( bubbleIds, bubbleId ) ) {
            map.removeLayer( bubblesLocal[bubbleId].circle );
            sounds[bubblesLocal[bubbleId].slot].stop();
            clearTimeout( bubblesLocal[bubbleId].soundTimeout );
            clearTimeout( bubblesLocal[bubbleId].soundStart );
            clearTimeout( bubblesLocal[bubbleId].soundStop );
            delete bubblesLocal[bubbleId];
        }
    });
};

//
// FORM STUFF
//

var setOptions = function(){
    // activate sounds
    _.each(sounds,function(sound){ sound.load(); });
    updateOptions();
    $(".js-start").blur();
    // close the form modal
    $('#js-player-edit').foundation('reveal', 'close');
};

// cookie stuff

var previousName = $.cookie('name');
if ( previousName ) {
    $(".js-form-name").val( previousName );
}

var previousSize = $.cookie('size');
if ( previousSize ) {
    $(".js-form-size").val( previousSize );
}

$(".js-start").on("click", setOptions);

$(".js-form").on("submit", function(e){
    e.preventDefault();
});

var updateOptions = function() {
    var options = {
        name : $(".js-form-name").val(),
        size : $(".js-form-size").val()
    };
    $.cookie('name', options.name);
    $.cookie('size', options.size);
    socket.emit('options', options);
};

//
// GEOLOCATION STUFF
//

var currentPos;

var newPosition = function(position) {
    //console.log("new position");
    // copy position over to currentPos
    currentPos = $.extend(true, {}, position);
};

var updater = window.setInterval(function(){
    if ( currentPos ) {
        socket.emit('position', currentPos);
    }
},500);

var geolocationError = function(error) {
    //console.log("geolocation error");
};

var watchId = navigator.geolocation.watchPosition(
    newPosition,
    geolocationError,
    {
        timeout: 1000,
        enableHighAccuracy: true,
        maximumAge: 0
    }
);

})();